{"./":{"url":"./","title":"序言","keywords":"","body":"前言 本书记录本人学习kubernetes的经历，还正在路上，希望能带大家由浅入深、全面系统地学习kubernetes，节约大家的时间，少走弯路，从入门到精通。 kubernetes 很复杂，学习门槛较高，市面上的学习资料往往很难让小白快速入门，需要有一定的基础才能弄懂很多操作和概念。这本书正是为了让大多数人能快速入门甚至精通kubernetes而设计的，用接地气的方式在合适的阶段讲合适的东西，不会一下子讲的很全面，因为你也不可能一下子记住那么多东西，还会拖慢你的学习速度。总之，你只需要按照本书的思路走，就可以循序渐进的掌握kubernetes。 学习思路 kubernetes 本书是个非常复杂、非常灵活的东西，要真正会用它不能只是照搬网上搜索的操作步骤，一定要弄明白它的原理和概念，不然遇到问题就只能各种搜索，可能还解决不了。本书会按照下面的思路来讲： 简单介绍在安装 kubernetes 之前需要了解的基础概念和原理，为后面的安装铺路，让你看懂每一步在做什么和为什么这么做 教你如何安装 kubernetes （了解前面的基础马上装，不然学后面的概念和操作就纸上谈兵了） 把 kubernetes 涉及到的概念详细的列出来作为参考（这部分不需要一下子看完，后面用到的时候来翻下就行） 各种插件的安装与使用 Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-01-22 14:13:52 "},"intro/introduce-kubernetes.html":{"url":"intro/introduce-kubernetes.html","title":"kubernetes简介","keywords":"","body":"Kubernetes 简介 什么是Kubernetes 简单来说就是一个容器的集群管理平台，你程序所需要的计算资源不再受单机资源的约束，可以将整个集群拥有的计算资源看成一块云，资源不够用就只需要增加机器，动态伸缩你的程序运行的数量就可以了。它不仅仅是集群管理，还可以让你只需要关注自己程序的逻辑，而服务发现、负载均衡、自动伸缩、滚动升级等这些你都不需要关心，它也不需要关心你用的什么语言，不侵入你的代码就能帮你完成这些，甚至它还有办法在你程序有bug的情况下尽量让你的程序正常提供服务。 kubernetes也是云原生的核心，整个生态飞速发展，日益壮大。服务网格(Service Mesh) 的出现如虎添翼，可以轻松实现和管理微服务，服务治理框架可能也将不再需要。 Kubernetes架构 为了更容易理解kubernetes架构，我先画了个简单版的架构图，屏蔽了很多细节 很容易看出来，kubernetes是用master来管理其它Node（工作负载的节点），当然master自身也是可以安装成Node的。 核心组件说明： apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； etcd 保存了整个集群的状态； controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等； scheduler 负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上； kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理； kube-proxy 负责为Service提供cluster内部的服务发现和负载均衡； 如何操作集群 操作集群方式有多种，它们的原理都是调用 API Server 的接口。 通过 kubectl 命令行工具 给集群装 dashboard 插件，通过网页可视化操作 用 Rancher 来管理 kubernetes，功能更加丰富 利用 SDK 写程序来做一些集群操作自动化 不管怎样，最终都要和 API Server 通信，都需要经过访问控制校验，kubernetes 主要利用 RBAC (基于角色的访问控制）来做的，接下来会将。 Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-01-22 14:13:52 "},"intro/kubernetes-authentication.html":{"url":"intro/kubernetes-authentication.html","title":"kubernetes权限控制","keywords":"","body":"Kubernetes 权限控制 \bKubernetes 的权限控制这块是\b理解其搭建\b过程中比较复杂也是比较重要的部分，这里先简单介绍下相关概念，为后面打下基础。 Namespace Kubernetes 集群中可包含多个 namespace，它们在逻辑上相互隔离，比如测试和生产如果在同一个 Kubernetes 集群上，可以用 namaspace 将它们隔离开，互不干扰。当然也可以通过一些方式跨 namespace 访问和操作，前提是分配了足够的权限。 RBAC——基于角色的访问控制 Kubernetes 的权限控制主要使用基于角色的访问控制（Role-Based Access Control, 即”RBAC”）\b，简单来说，就是不管是\b集群管理员还是集群中的程序，把它们都看用户，它们要想对集群进行访问或操作，就需要相应的权限，权限通过角色\b来代表，每个角色可以被赋予一组权限，角色可以绑定到\b用户上，绑定之后用户就拥有了相应的权限。 用户与用户组 Kubernetes 集群中包含两类用户： \bUser : \b限制集群管理员的权限。比如刚开始学习我们可以都用最高管理员权限，可以在集群中任何 namespace 下进行访问和各种操作。到了生产环境，如果集群比较大，操作的人比较多，管理员权限的分配可能就需要更加细化了。 \bService Account : 服务账号，限制集群\b中运行的程序的权限。比如 Kubernetes 自身的组件或一些插件，往往它们都需要对整个集群的一些状态和数据进行读写操作，就需要相应的权限；而一些普通的程序可能不需要很高的权限，我们最好就不需要给那么高的权限，以免发生意外。 我们一般要创建的是 Service Account， 定义示例： apiVersion: v1 kind: ServiceAccount metadata: name: admin namespace: kube-system labels: kubernetes.io/cluster-service: \"true\" addonmanager.kubernetes.io/mode: Reconcile 用户组： Group : 用于给一组\b用户赋予相同的权限。 角色 角色用来代表一组权限，在 Kubernetes 中有两类角色： Role : 代表某个 namaspace 下的一组权限。 一个Role对象只能用于授予对某一单一命名空间中资源的访问权限。 以下示例描述了”default”命名空间中的一个Role对象的定义，用于授予对pod的读访问权限： kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: default name: pod-reader rules: - apiGroups: [\"\"] # 空字符串\"\"表明使用core API group resources: [\"pods\"] verbs: [\"get\", \"watch\", \"list\"] ClusterRole : 代表整个集群范围内的一组权限。 ClusterRole 定义示例： kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: # 鉴于ClusterRole是集群范围对象，所以这里不需要定义\"namespace\"字段 name: secret-reader rules: - apiGroups: [\"\"] resources: [\"secrets\"] verbs: [\"get\", \"watch\", \"list\"] 角色绑定 可以给某个用户或某个用户组分配一组权限，通过角色绑定来实现。分两类： RoleBinding : 绑定的权限只作用于某个 namespace 下。 定义示例： # 以下角色绑定定义将允许用户\"jane\"从\"default\"命名空间中读取pod。 kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: read-pods namespace: default subjects: - kind: User name: jane apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io ClusterRoleBinding : 绑定的权限作用于整个集群。 定义示例：\b # 以下`ClusterRoleBinding`对象允许在用户组\"manager\"中的任何用户都可以读取集群中任何命名空间中的secret。 kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: read-secrets-global subjects: - kind: Group name: manager apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io 注： RoleBinding 中的 roleRef 也可以用 ClusterRole，只不过将 ClusterRole 中定义的权限限定在某 namespace 下，通常用于预先定义一些通用的角色，在多个 namespace 下复用。定义示例： # 以下角色绑定允许用户\"dave\"读取\"development\"命名空间中的secret。 kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: read-secrets namespace: development # 这里表明仅授权读取\"development\"命名空间中的资源。 subjects: - kind: User name: dave apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io TLS Kubernetes 的权限校验是通过校验证书来实现的，提取证书中的 CN(Common Name) 字段作为用户名，O(Organization) 字段作为用户组\b。 Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-01-22 14:16:09 "},"install-kubernetes/install-kubernetes.html":{"url":"install-kubernetes/install-kubernetes.html","title":"概述","keywords":"","body":"安装说明 kubernetes 本身非常灵活，把不同功能模块拆成了多个独立运行的组件，有些组件还有第三方可替代品，还有各种插件，根据自己需求安装所需模块。 要找到适合自己需求的安装方式需要对 kubernetes 有着一定程度的理解，在前期学习的时候建议先搭建一个通用的简单版 kubernetes，这样能解决大部分普通需求，至少可以上手各种实践操作，后面再慢慢深入原理与概念。 Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-02-05 21:11:29 "},"install-kubernetes/install-kubernetes-1.9-on-centos7/install-kubernetes-1.9-on-centos7.html":{"url":"install-kubernetes/install-kubernetes-1.9-on-centos7/install-kubernetes-1.9-on-centos7.html","title":"在CentOS 7上部署Kubernetes v1.9","keywords":"","body":"在CentOS 7 上安装Kubernetes v1.9 Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-01-22 14:58:43 "},"install-kubernetes/install-kubernetes-1.9-on-centos7/create-key-and-crt.html":{"url":"install-kubernetes/install-kubernetes-1.9-on-centos7/create-key-and-crt.html","title":"创建证书和密钥","keywords":"","body":"创建证书和密钥 安装 CFSSL wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 chmod +x cfssl_linux-amd64 mv cfssl_linux-amd64 /usr/local/bin/cfssl wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 chmod +x cfssljson_linux-amd64 mv cfssljson_linux-amd64 /usr/local/bin/cfssljson wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 chmod +x cfssl-certinfo_linux-amd64 mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo 创建 CA 创建 CA 配置文件 创建 ca-config.json 文件，它是后面每次生成证书的时候要用到的配置文件，内容如下： { \"signing\": { \"default\": { \"expiry\": \"87600h\" }, \"profiles\": { \"kubernetes\": { \"usages\": [ \"signing\", \"key encipherment\", \"server auth\", \"client auth\" ], \"expiry\": \"87600h\" } } } } 创建 CA 证书签名请求 创建 ca-csr.json 文件，它是生成CA证书和密钥用到的特有配置文件，内容如下： { \"CN\": \"kubernetes\", \"key\": { \"algo\": \"rsa\", \"size\": 2048 }, \"names\": [ { \"C\": \"CN\", \"ST\": \"BeiJing\", \"L\": \"BeiJing\", \"O\": \"k8s\", \"OU\": \"System\" } ] } 生成 CA 证书和私钥 $ cfssl gencert -initca ca-csr.json | cfssljson -bare ca $ ls ca* ca-config.json ca.csr ca-csr.json ca-key.pem ca.pem 创建Master证书 创建 kubernetes-csr.json 文件，内容如下： { \"CN\": \"kubernetes\", \"hosts\": [ \"172.20.0.112\", \"172.20.0.113\", \"172.20.0.114\", \"172.20.0.115\", \"127.0.0.1\", \"10.254.0.1\", \"kubernetes\", \"kubernetes.default\", \"kubernetes.default.svc\", \"kubernetes.default.svc.cluster\", \"kubernetes.default.svc.cluster.local\" ], \"key\": { \"algo\": \"rsa\", \"size\": 2048 }, \"names\": [ { \"C\": \"CN\", \"ST\": \"BeiJing\", \"L\": \"BeiJing\", \"O\": \"k8s\", \"OU\": \"System\" } ] } 将 hosts 前面几个 172 开头的IP换成master机器的内网IP 生成 master 证书和私钥 $ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes $ ls kubernetes* kubernetes.csr kubernetes-csr.json kubernetes-key.pem kubernetes.pem 创建 admin 证书 管理员使用 kubectl 操作集群，使用下面的 admin 证书具有最高权限，创建 admin-csr.json 文件，内容如下： { \"CN\": \"admin\", \"hosts\": [], \"key\": { \"algo\": \"rsa\", \"size\": 2048 }, \"names\": [ { \"C\": \"CN\", \"ST\": \"BeiJing\", \"L\": \"BeiJing\", \"O\": \"system:masters\", \"OU\": \"System\" } ] } 生成 admin 证书和私钥 $ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin $ ls admin* admin.csr admin-csr.json admin-key.pem admin.pem 创建 kube-proxy 证书 创建 kube-proxy-csr.json 文件，内容如下： { \"CN\": \"system:kube-proxy\", \"hosts\": [], \"key\": { \"algo\": \"rsa\", \"size\": 2048 }, \"names\": [ { \"C\": \"CN\", \"ST\": \"BeiJing\", \"L\": \"BeiJing\", \"O\": \"k8s\", \"OU\": \"System\" } ] } 生成 kube-proxy 证书和私钥 $ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy $ ls kube-proxy* kube-proxy.csr kube-proxy-csr.json kube-proxy-key.pem kube-proxy.pem 校验证书 以 master 证书为例： cfssl-certinfo -cert kubernetes.pem 分发证书 将生成的证书和秘钥文件（后缀名为.pem）拷贝到所有机器的 /etc/kubernetes/ssl 目录下备用: mkdir -p /etc/kubernetes/ssl cp *.pem /etc/kubernetes/ssl Copyright © imroc.io 2018 all right reserved，powered by GitbookUpdated: 2018-02-05 22:30:21 "}}